// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: LoginMessages.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_LoginMessages_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_LoginMessages_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021002 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_LoginMessages_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_LoginMessages_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_LoginMessages_2eproto;
class CheckRegParameterStatus;
struct CheckRegParameterStatusDefaultTypeInternal;
extern CheckRegParameterStatusDefaultTypeInternal _CheckRegParameterStatus_default_instance_;
class Login;
struct LoginDefaultTypeInternal;
extern LoginDefaultTypeInternal _Login_default_instance_;
class Registration;
struct RegistrationDefaultTypeInternal;
extern RegistrationDefaultTypeInternal _Registration_default_instance_;
PROTOBUF_NAMESPACE_OPEN
template<> ::CheckRegParameterStatus* Arena::CreateMaybeMessage<::CheckRegParameterStatus>(Arena*);
template<> ::Login* Arena::CreateMaybeMessage<::Login>(Arena*);
template<> ::Registration* Arena::CreateMaybeMessage<::Registration>(Arena*);
PROTOBUF_NAMESPACE_CLOSE

enum MsgState : int {
  MS_ERROR = 0,
  MS_INIT = 1,
  MS_SUCCESSFUL = 2,
  MsgState_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  MsgState_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool MsgState_IsValid(int value);
constexpr MsgState MsgState_MIN = MS_ERROR;
constexpr MsgState MsgState_MAX = MS_SUCCESSFUL;
constexpr int MsgState_ARRAYSIZE = MsgState_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* MsgState_descriptor();
template<typename T>
inline const std::string& MsgState_Name(T enum_t_value) {
  static_assert(::std::is_same<T, MsgState>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function MsgState_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    MsgState_descriptor(), enum_t_value);
}
inline bool MsgState_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, MsgState* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<MsgState>(
    MsgState_descriptor(), name, value);
}
// ===================================================================

class CheckRegParameterStatus final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CheckRegParameterStatus) */ {
 public:
  inline CheckRegParameterStatus() : CheckRegParameterStatus(nullptr) {}
  ~CheckRegParameterStatus() override;
  explicit PROTOBUF_CONSTEXPR CheckRegParameterStatus(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CheckRegParameterStatus(const CheckRegParameterStatus& from);
  CheckRegParameterStatus(CheckRegParameterStatus&& from) noexcept
    : CheckRegParameterStatus() {
    *this = ::std::move(from);
  }

  inline CheckRegParameterStatus& operator=(const CheckRegParameterStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline CheckRegParameterStatus& operator=(CheckRegParameterStatus&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CheckRegParameterStatus& default_instance() {
    return *internal_default_instance();
  }
  enum V1Case {
    kLogin = 1,
    kMail = 2,
    kLoginStatus = 3,
    kMailStatus = 4,
    V1_NOT_SET = 0,
  };

  static inline const CheckRegParameterStatus* internal_default_instance() {
    return reinterpret_cast<const CheckRegParameterStatus*>(
               &_CheckRegParameterStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(CheckRegParameterStatus& a, CheckRegParameterStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(CheckRegParameterStatus* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CheckRegParameterStatus* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CheckRegParameterStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CheckRegParameterStatus>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CheckRegParameterStatus& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CheckRegParameterStatus& from) {
    CheckRegParameterStatus::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CheckRegParameterStatus* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CheckRegParameterStatus";
  }
  protected:
  explicit CheckRegParameterStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLoginFieldNumber = 1,
    kMailFieldNumber = 2,
    kLoginStatusFieldNumber = 3,
    kMailStatusFieldNumber = 4,
  };
  // string login = 1;
  bool has_login() const;
  private:
  bool _internal_has_login() const;
  public:
  void clear_login();
  const std::string& login() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_login(ArgT0&& arg0, ArgT... args);
  std::string* mutable_login();
  PROTOBUF_NODISCARD std::string* release_login();
  void set_allocated_login(std::string* login);
  private:
  const std::string& _internal_login() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_login(const std::string& value);
  std::string* _internal_mutable_login();
  public:

  // string mail = 2;
  bool has_mail() const;
  private:
  bool _internal_has_mail() const;
  public:
  void clear_mail();
  const std::string& mail() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_mail(ArgT0&& arg0, ArgT... args);
  std::string* mutable_mail();
  PROTOBUF_NODISCARD std::string* release_mail();
  void set_allocated_mail(std::string* mail);
  private:
  const std::string& _internal_mail() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_mail(const std::string& value);
  std::string* _internal_mutable_mail();
  public:

  // bool loginStatus = 3;
  bool has_loginstatus() const;
  private:
  bool _internal_has_loginstatus() const;
  public:
  void clear_loginstatus();
  bool loginstatus() const;
  void set_loginstatus(bool value);
  private:
  bool _internal_loginstatus() const;
  void _internal_set_loginstatus(bool value);
  public:

  // bool mailStatus = 4;
  bool has_mailstatus() const;
  private:
  bool _internal_has_mailstatus() const;
  public:
  void clear_mailstatus();
  bool mailstatus() const;
  void set_mailstatus(bool value);
  private:
  bool _internal_mailstatus() const;
  void _internal_set_mailstatus(bool value);
  public:

  void clear_v1();
  V1Case v1_case() const;
  // @@protoc_insertion_point(class_scope:CheckRegParameterStatus)
 private:
  class _Internal;
  void set_has_login();
  void set_has_mail();
  void set_has_loginstatus();
  void set_has_mailstatus();

  inline bool has_v1() const;
  inline void clear_has_v1();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union V1Union {
      constexpr V1Union() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr login_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr mail_;
      bool loginstatus_;
      bool mailstatus_;
    } v1_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_LoginMessages_2eproto;
};
// -------------------------------------------------------------------

class Login final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Login) */ {
 public:
  inline Login() : Login(nullptr) {}
  ~Login() override;
  explicit PROTOBUF_CONSTEXPR Login(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Login(const Login& from);
  Login(Login&& from) noexcept
    : Login() {
    *this = ::std::move(from);
  }

  inline Login& operator=(const Login& from) {
    CopyFrom(from);
    return *this;
  }
  inline Login& operator=(Login&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Login& default_instance() {
    return *internal_default_instance();
  }
  static inline const Login* internal_default_instance() {
    return reinterpret_cast<const Login*>(
               &_Login_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Login& a, Login& b) {
    a.Swap(&b);
  }
  inline void Swap(Login* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Login* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Login* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Login>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Login& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Login& from) {
    Login::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Login* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Login";
  }
  protected:
  explicit Login(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMailFieldNumber = 1,
    kHashFieldNumber = 2,
    kStateFieldNumber = 3,
  };
  // string mail = 1;
  void clear_mail();
  const std::string& mail() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_mail(ArgT0&& arg0, ArgT... args);
  std::string* mutable_mail();
  PROTOBUF_NODISCARD std::string* release_mail();
  void set_allocated_mail(std::string* mail);
  private:
  const std::string& _internal_mail() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_mail(const std::string& value);
  std::string* _internal_mutable_mail();
  public:

  // string hash = 2;
  void clear_hash();
  const std::string& hash() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_hash(ArgT0&& arg0, ArgT... args);
  std::string* mutable_hash();
  PROTOBUF_NODISCARD std::string* release_hash();
  void set_allocated_hash(std::string* hash);
  private:
  const std::string& _internal_hash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_hash(const std::string& value);
  std::string* _internal_mutable_hash();
  public:

  // .MsgState state = 3;
  void clear_state();
  ::MsgState state() const;
  void set_state(::MsgState value);
  private:
  ::MsgState _internal_state() const;
  void _internal_set_state(::MsgState value);
  public:

  // @@protoc_insertion_point(class_scope:Login)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr mail_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr hash_;
    int state_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_LoginMessages_2eproto;
};
// -------------------------------------------------------------------

class Registration final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Registration) */ {
 public:
  inline Registration() : Registration(nullptr) {}
  ~Registration() override;
  explicit PROTOBUF_CONSTEXPR Registration(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Registration(const Registration& from);
  Registration(Registration&& from) noexcept
    : Registration() {
    *this = ::std::move(from);
  }

  inline Registration& operator=(const Registration& from) {
    CopyFrom(from);
    return *this;
  }
  inline Registration& operator=(Registration&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Registration& default_instance() {
    return *internal_default_instance();
  }
  static inline const Registration* internal_default_instance() {
    return reinterpret_cast<const Registration*>(
               &_Registration_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Registration& a, Registration& b) {
    a.Swap(&b);
  }
  inline void Swap(Registration* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Registration* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Registration* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Registration>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Registration& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Registration& from) {
    Registration::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Registration* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Registration";
  }
  protected:
  explicit Registration(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLoginFieldNumber = 1,
    kHashFieldNumber = 2,
    kMailFieldNumber = 3,
    kStateFieldNumber = 4,
  };
  // string login = 1;
  void clear_login();
  const std::string& login() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_login(ArgT0&& arg0, ArgT... args);
  std::string* mutable_login();
  PROTOBUF_NODISCARD std::string* release_login();
  void set_allocated_login(std::string* login);
  private:
  const std::string& _internal_login() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_login(const std::string& value);
  std::string* _internal_mutable_login();
  public:

  // string hash = 2;
  void clear_hash();
  const std::string& hash() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_hash(ArgT0&& arg0, ArgT... args);
  std::string* mutable_hash();
  PROTOBUF_NODISCARD std::string* release_hash();
  void set_allocated_hash(std::string* hash);
  private:
  const std::string& _internal_hash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_hash(const std::string& value);
  std::string* _internal_mutable_hash();
  public:

  // string mail = 3;
  void clear_mail();
  const std::string& mail() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_mail(ArgT0&& arg0, ArgT... args);
  std::string* mutable_mail();
  PROTOBUF_NODISCARD std::string* release_mail();
  void set_allocated_mail(std::string* mail);
  private:
  const std::string& _internal_mail() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_mail(const std::string& value);
  std::string* _internal_mutable_mail();
  public:

  // .MsgState state = 4;
  void clear_state();
  ::MsgState state() const;
  void set_state(::MsgState value);
  private:
  ::MsgState _internal_state() const;
  void _internal_set_state(::MsgState value);
  public:

  // @@protoc_insertion_point(class_scope:Registration)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr login_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr hash_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr mail_;
    int state_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_LoginMessages_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// CheckRegParameterStatus

// string login = 1;
inline bool CheckRegParameterStatus::_internal_has_login() const {
  return v1_case() == kLogin;
}
inline bool CheckRegParameterStatus::has_login() const {
  return _internal_has_login();
}
inline void CheckRegParameterStatus::set_has_login() {
  _impl_._oneof_case_[0] = kLogin;
}
inline void CheckRegParameterStatus::clear_login() {
  if (_internal_has_login()) {
    _impl_.v1_.login_.Destroy();
    clear_has_v1();
  }
}
inline const std::string& CheckRegParameterStatus::login() const {
  // @@protoc_insertion_point(field_get:CheckRegParameterStatus.login)
  return _internal_login();
}
template <typename ArgT0, typename... ArgT>
inline void CheckRegParameterStatus::set_login(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_login()) {
    clear_v1();
    set_has_login();
    _impl_.v1_.login_.InitDefault();
  }
  _impl_.v1_.login_.Set( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CheckRegParameterStatus.login)
}
inline std::string* CheckRegParameterStatus::mutable_login() {
  std::string* _s = _internal_mutable_login();
  // @@protoc_insertion_point(field_mutable:CheckRegParameterStatus.login)
  return _s;
}
inline const std::string& CheckRegParameterStatus::_internal_login() const {
  if (_internal_has_login()) {
    return _impl_.v1_.login_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void CheckRegParameterStatus::_internal_set_login(const std::string& value) {
  if (!_internal_has_login()) {
    clear_v1();
    set_has_login();
    _impl_.v1_.login_.InitDefault();
  }
  _impl_.v1_.login_.Set(value, GetArenaForAllocation());
}
inline std::string* CheckRegParameterStatus::_internal_mutable_login() {
  if (!_internal_has_login()) {
    clear_v1();
    set_has_login();
    _impl_.v1_.login_.InitDefault();
  }
  return _impl_.v1_.login_.Mutable(      GetArenaForAllocation());
}
inline std::string* CheckRegParameterStatus::release_login() {
  // @@protoc_insertion_point(field_release:CheckRegParameterStatus.login)
  if (_internal_has_login()) {
    clear_has_v1();
    return _impl_.v1_.login_.Release();
  } else {
    return nullptr;
  }
}
inline void CheckRegParameterStatus::set_allocated_login(std::string* login) {
  if (has_v1()) {
    clear_v1();
  }
  if (login != nullptr) {
    set_has_login();
    _impl_.v1_.login_.InitAllocated(login, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:CheckRegParameterStatus.login)
}

// string mail = 2;
inline bool CheckRegParameterStatus::_internal_has_mail() const {
  return v1_case() == kMail;
}
inline bool CheckRegParameterStatus::has_mail() const {
  return _internal_has_mail();
}
inline void CheckRegParameterStatus::set_has_mail() {
  _impl_._oneof_case_[0] = kMail;
}
inline void CheckRegParameterStatus::clear_mail() {
  if (_internal_has_mail()) {
    _impl_.v1_.mail_.Destroy();
    clear_has_v1();
  }
}
inline const std::string& CheckRegParameterStatus::mail() const {
  // @@protoc_insertion_point(field_get:CheckRegParameterStatus.mail)
  return _internal_mail();
}
template <typename ArgT0, typename... ArgT>
inline void CheckRegParameterStatus::set_mail(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_mail()) {
    clear_v1();
    set_has_mail();
    _impl_.v1_.mail_.InitDefault();
  }
  _impl_.v1_.mail_.Set( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CheckRegParameterStatus.mail)
}
inline std::string* CheckRegParameterStatus::mutable_mail() {
  std::string* _s = _internal_mutable_mail();
  // @@protoc_insertion_point(field_mutable:CheckRegParameterStatus.mail)
  return _s;
}
inline const std::string& CheckRegParameterStatus::_internal_mail() const {
  if (_internal_has_mail()) {
    return _impl_.v1_.mail_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void CheckRegParameterStatus::_internal_set_mail(const std::string& value) {
  if (!_internal_has_mail()) {
    clear_v1();
    set_has_mail();
    _impl_.v1_.mail_.InitDefault();
  }
  _impl_.v1_.mail_.Set(value, GetArenaForAllocation());
}
inline std::string* CheckRegParameterStatus::_internal_mutable_mail() {
  if (!_internal_has_mail()) {
    clear_v1();
    set_has_mail();
    _impl_.v1_.mail_.InitDefault();
  }
  return _impl_.v1_.mail_.Mutable(      GetArenaForAllocation());
}
inline std::string* CheckRegParameterStatus::release_mail() {
  // @@protoc_insertion_point(field_release:CheckRegParameterStatus.mail)
  if (_internal_has_mail()) {
    clear_has_v1();
    return _impl_.v1_.mail_.Release();
  } else {
    return nullptr;
  }
}
inline void CheckRegParameterStatus::set_allocated_mail(std::string* mail) {
  if (has_v1()) {
    clear_v1();
  }
  if (mail != nullptr) {
    set_has_mail();
    _impl_.v1_.mail_.InitAllocated(mail, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:CheckRegParameterStatus.mail)
}

// bool loginStatus = 3;
inline bool CheckRegParameterStatus::_internal_has_loginstatus() const {
  return v1_case() == kLoginStatus;
}
inline bool CheckRegParameterStatus::has_loginstatus() const {
  return _internal_has_loginstatus();
}
inline void CheckRegParameterStatus::set_has_loginstatus() {
  _impl_._oneof_case_[0] = kLoginStatus;
}
inline void CheckRegParameterStatus::clear_loginstatus() {
  if (_internal_has_loginstatus()) {
    _impl_.v1_.loginstatus_ = false;
    clear_has_v1();
  }
}
inline bool CheckRegParameterStatus::_internal_loginstatus() const {
  if (_internal_has_loginstatus()) {
    return _impl_.v1_.loginstatus_;
  }
  return false;
}
inline void CheckRegParameterStatus::_internal_set_loginstatus(bool value) {
  if (!_internal_has_loginstatus()) {
    clear_v1();
    set_has_loginstatus();
  }
  _impl_.v1_.loginstatus_ = value;
}
inline bool CheckRegParameterStatus::loginstatus() const {
  // @@protoc_insertion_point(field_get:CheckRegParameterStatus.loginStatus)
  return _internal_loginstatus();
}
inline void CheckRegParameterStatus::set_loginstatus(bool value) {
  _internal_set_loginstatus(value);
  // @@protoc_insertion_point(field_set:CheckRegParameterStatus.loginStatus)
}

// bool mailStatus = 4;
inline bool CheckRegParameterStatus::_internal_has_mailstatus() const {
  return v1_case() == kMailStatus;
}
inline bool CheckRegParameterStatus::has_mailstatus() const {
  return _internal_has_mailstatus();
}
inline void CheckRegParameterStatus::set_has_mailstatus() {
  _impl_._oneof_case_[0] = kMailStatus;
}
inline void CheckRegParameterStatus::clear_mailstatus() {
  if (_internal_has_mailstatus()) {
    _impl_.v1_.mailstatus_ = false;
    clear_has_v1();
  }
}
inline bool CheckRegParameterStatus::_internal_mailstatus() const {
  if (_internal_has_mailstatus()) {
    return _impl_.v1_.mailstatus_;
  }
  return false;
}
inline void CheckRegParameterStatus::_internal_set_mailstatus(bool value) {
  if (!_internal_has_mailstatus()) {
    clear_v1();
    set_has_mailstatus();
  }
  _impl_.v1_.mailstatus_ = value;
}
inline bool CheckRegParameterStatus::mailstatus() const {
  // @@protoc_insertion_point(field_get:CheckRegParameterStatus.mailStatus)
  return _internal_mailstatus();
}
inline void CheckRegParameterStatus::set_mailstatus(bool value) {
  _internal_set_mailstatus(value);
  // @@protoc_insertion_point(field_set:CheckRegParameterStatus.mailStatus)
}

inline bool CheckRegParameterStatus::has_v1() const {
  return v1_case() != V1_NOT_SET;
}
inline void CheckRegParameterStatus::clear_has_v1() {
  _impl_._oneof_case_[0] = V1_NOT_SET;
}
inline CheckRegParameterStatus::V1Case CheckRegParameterStatus::v1_case() const {
  return CheckRegParameterStatus::V1Case(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// Login

// string mail = 1;
inline void Login::clear_mail() {
  _impl_.mail_.ClearToEmpty();
}
inline const std::string& Login::mail() const {
  // @@protoc_insertion_point(field_get:Login.mail)
  return _internal_mail();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Login::set_mail(ArgT0&& arg0, ArgT... args) {
 
 _impl_.mail_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Login.mail)
}
inline std::string* Login::mutable_mail() {
  std::string* _s = _internal_mutable_mail();
  // @@protoc_insertion_point(field_mutable:Login.mail)
  return _s;
}
inline const std::string& Login::_internal_mail() const {
  return _impl_.mail_.Get();
}
inline void Login::_internal_set_mail(const std::string& value) {
  
  _impl_.mail_.Set(value, GetArenaForAllocation());
}
inline std::string* Login::_internal_mutable_mail() {
  
  return _impl_.mail_.Mutable(GetArenaForAllocation());
}
inline std::string* Login::release_mail() {
  // @@protoc_insertion_point(field_release:Login.mail)
  return _impl_.mail_.Release();
}
inline void Login::set_allocated_mail(std::string* mail) {
  if (mail != nullptr) {
    
  } else {
    
  }
  _impl_.mail_.SetAllocated(mail, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.mail_.IsDefault()) {
    _impl_.mail_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Login.mail)
}

// string hash = 2;
inline void Login::clear_hash() {
  _impl_.hash_.ClearToEmpty();
}
inline const std::string& Login::hash() const {
  // @@protoc_insertion_point(field_get:Login.hash)
  return _internal_hash();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Login::set_hash(ArgT0&& arg0, ArgT... args) {
 
 _impl_.hash_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Login.hash)
}
inline std::string* Login::mutable_hash() {
  std::string* _s = _internal_mutable_hash();
  // @@protoc_insertion_point(field_mutable:Login.hash)
  return _s;
}
inline const std::string& Login::_internal_hash() const {
  return _impl_.hash_.Get();
}
inline void Login::_internal_set_hash(const std::string& value) {
  
  _impl_.hash_.Set(value, GetArenaForAllocation());
}
inline std::string* Login::_internal_mutable_hash() {
  
  return _impl_.hash_.Mutable(GetArenaForAllocation());
}
inline std::string* Login::release_hash() {
  // @@protoc_insertion_point(field_release:Login.hash)
  return _impl_.hash_.Release();
}
inline void Login::set_allocated_hash(std::string* hash) {
  if (hash != nullptr) {
    
  } else {
    
  }
  _impl_.hash_.SetAllocated(hash, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.hash_.IsDefault()) {
    _impl_.hash_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Login.hash)
}

// .MsgState state = 3;
inline void Login::clear_state() {
  _impl_.state_ = 0;
}
inline ::MsgState Login::_internal_state() const {
  return static_cast< ::MsgState >(_impl_.state_);
}
inline ::MsgState Login::state() const {
  // @@protoc_insertion_point(field_get:Login.state)
  return _internal_state();
}
inline void Login::_internal_set_state(::MsgState value) {
  
  _impl_.state_ = value;
}
inline void Login::set_state(::MsgState value) {
  _internal_set_state(value);
  // @@protoc_insertion_point(field_set:Login.state)
}

// -------------------------------------------------------------------

// Registration

// string login = 1;
inline void Registration::clear_login() {
  _impl_.login_.ClearToEmpty();
}
inline const std::string& Registration::login() const {
  // @@protoc_insertion_point(field_get:Registration.login)
  return _internal_login();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Registration::set_login(ArgT0&& arg0, ArgT... args) {
 
 _impl_.login_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Registration.login)
}
inline std::string* Registration::mutable_login() {
  std::string* _s = _internal_mutable_login();
  // @@protoc_insertion_point(field_mutable:Registration.login)
  return _s;
}
inline const std::string& Registration::_internal_login() const {
  return _impl_.login_.Get();
}
inline void Registration::_internal_set_login(const std::string& value) {
  
  _impl_.login_.Set(value, GetArenaForAllocation());
}
inline std::string* Registration::_internal_mutable_login() {
  
  return _impl_.login_.Mutable(GetArenaForAllocation());
}
inline std::string* Registration::release_login() {
  // @@protoc_insertion_point(field_release:Registration.login)
  return _impl_.login_.Release();
}
inline void Registration::set_allocated_login(std::string* login) {
  if (login != nullptr) {
    
  } else {
    
  }
  _impl_.login_.SetAllocated(login, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.login_.IsDefault()) {
    _impl_.login_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Registration.login)
}

// string hash = 2;
inline void Registration::clear_hash() {
  _impl_.hash_.ClearToEmpty();
}
inline const std::string& Registration::hash() const {
  // @@protoc_insertion_point(field_get:Registration.hash)
  return _internal_hash();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Registration::set_hash(ArgT0&& arg0, ArgT... args) {
 
 _impl_.hash_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Registration.hash)
}
inline std::string* Registration::mutable_hash() {
  std::string* _s = _internal_mutable_hash();
  // @@protoc_insertion_point(field_mutable:Registration.hash)
  return _s;
}
inline const std::string& Registration::_internal_hash() const {
  return _impl_.hash_.Get();
}
inline void Registration::_internal_set_hash(const std::string& value) {
  
  _impl_.hash_.Set(value, GetArenaForAllocation());
}
inline std::string* Registration::_internal_mutable_hash() {
  
  return _impl_.hash_.Mutable(GetArenaForAllocation());
}
inline std::string* Registration::release_hash() {
  // @@protoc_insertion_point(field_release:Registration.hash)
  return _impl_.hash_.Release();
}
inline void Registration::set_allocated_hash(std::string* hash) {
  if (hash != nullptr) {
    
  } else {
    
  }
  _impl_.hash_.SetAllocated(hash, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.hash_.IsDefault()) {
    _impl_.hash_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Registration.hash)
}

// string mail = 3;
inline void Registration::clear_mail() {
  _impl_.mail_.ClearToEmpty();
}
inline const std::string& Registration::mail() const {
  // @@protoc_insertion_point(field_get:Registration.mail)
  return _internal_mail();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Registration::set_mail(ArgT0&& arg0, ArgT... args) {
 
 _impl_.mail_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Registration.mail)
}
inline std::string* Registration::mutable_mail() {
  std::string* _s = _internal_mutable_mail();
  // @@protoc_insertion_point(field_mutable:Registration.mail)
  return _s;
}
inline const std::string& Registration::_internal_mail() const {
  return _impl_.mail_.Get();
}
inline void Registration::_internal_set_mail(const std::string& value) {
  
  _impl_.mail_.Set(value, GetArenaForAllocation());
}
inline std::string* Registration::_internal_mutable_mail() {
  
  return _impl_.mail_.Mutable(GetArenaForAllocation());
}
inline std::string* Registration::release_mail() {
  // @@protoc_insertion_point(field_release:Registration.mail)
  return _impl_.mail_.Release();
}
inline void Registration::set_allocated_mail(std::string* mail) {
  if (mail != nullptr) {
    
  } else {
    
  }
  _impl_.mail_.SetAllocated(mail, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.mail_.IsDefault()) {
    _impl_.mail_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Registration.mail)
}

// .MsgState state = 4;
inline void Registration::clear_state() {
  _impl_.state_ = 0;
}
inline ::MsgState Registration::_internal_state() const {
  return static_cast< ::MsgState >(_impl_.state_);
}
inline ::MsgState Registration::state() const {
  // @@protoc_insertion_point(field_get:Registration.state)
  return _internal_state();
}
inline void Registration::_internal_set_state(::MsgState value) {
  
  _impl_.state_ = value;
}
inline void Registration::set_state(::MsgState value) {
  _internal_set_state(value);
  // @@protoc_insertion_point(field_set:Registration.state)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::MsgState> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::MsgState>() {
  return ::MsgState_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_LoginMessages_2eproto
